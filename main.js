// Generated by CoffeeScript 2.4.1
(function() {
  //todo
  //  lazy-login to thetvdb
  //  add episode dupes to counter summary
  //  move episode dupes code to this file

  // debug = true
  var badFile, blocked, blockedCount, checkFile, checkFileExists, checkFiles, chkCount, chkTvDB, delOldFiles, deleteCount, downloadCount, errCount, errors, escQuotes, escQuotesS, exec, existsCount, f, fileTimeout, filterRegex, filterRegexTxt, findUsb, fname, fs, getUsbFiles, i, len, line, map, mapLines, mapStr, mkdirp, recent, recentCount, recentLimit, request, rimraf, season, seriesName, startTime, t, theTvDbToken, time, title, tvDbErrCount, tvPath, tvdbCache, type, usbAgeLimit, usbFilePath, usbFiles, usbHost, util;

  usbHost = "xobtlu@oracle.usbx.me";

  usbAgeLimit = Date.now() - 2 * 7 * 24 * 60 * 60 * 1000; // 2 weeks ago

  recentLimit = Date.now() - 3 * 7 * 24 * 60 * 60 * 1000; // 3 weeks ago

  fileTimeout = {
    timeout: 2 * 60 * 60 * 1000 // 2 hours
  };

  fs = require('fs-plus');

  util = require('util');

  exec = require('child_process').execSync;

  mkdirp = require('mkdirp');

  request = require('request');

  rimraf = require('rimraf');

  filterRegex = null;

  filterRegexTxt = '';

  if (process.argv.length === 3) {
    filterRegex = process.argv[2];
    filterRegexTxt = 'filter:' + filterRegex;
  }

  console.log(`.... starting tv.coffee v4 ${filterRegexTxt} ....`);

  startTime = time = Date.now();

  deleteCount = chkCount = recentCount = 0;

  existsCount = errCount = downloadCount = blockedCount = 0;

  findUsb = `ssh ${usbHost} find files -type f -printf '%CY-%Cm-%Cd-%P\\\\\\n' | grep -v .r[0-9][0-9]$ | grep -v .rar$`;

  if (filterRegex) {
    findUsb += " | grep " + filterRegex;
  }

  //##########
  // constants
  map = {};

  mapStr = fs.readFileSync('tv-map', 'utf8');

  mapLines = mapStr.split('\n');

  for (i = 0, len = mapLines.length; i < len; i++) {
    line = mapLines[i];
    [f, t] = line.split(',');
    if (line.length) {
      map[f.trim()] = t.trim();
    }
  }

  blocked = JSON.parse(fs.readFileSync('tv-blocked.json', 'utf8'));

  recent = JSON.parse(fs.readFileSync('tv-recent.json', 'utf8'));

  errors = JSON.parse(fs.readFileSync('tv-errors', 'utf8'));

  tvPath = '/mnt/media/tv/';

  escQuotesS = function(str) {
    return '"' + str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/'/g, "\\'").replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\&/g, "\\&").replace(/\s/g, '\\ ') + '"';
  };

  escQuotes = function(str) {
    return '"' + str.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
  };

  // '"' + str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/'/g, "\\'") + '"'

  //###############
  // async routines
  getUsbFiles = delOldFiles = checkFiles = checkFile = badFile = checkFileExists = checkFile = chkTvDB = null;

  //######################################
  // get the api token
  theTvDbToken = null;

  request.post('https://api.thetvdb.com/login', {
    json: true,
    body: {
      apikey: "2C92771D87CA8718"
    }
  }, (error, response, body) => {
    if (error || response.statusCode !== 200) {
      console.error('theTvDb login error:', error);
      console.error('theTvDb statusCode:', response && response.statusCode);
      return process.exit();
    } else {
      theTvDbToken = body.token;
      // if debug
      //   console.log 'tvdb login', {error, response, body}
      //   process.exit()
      return process.nextTick(delOldFiles);
    }
  });

  //#####################################################
  // delete old files in usb/files
  delOldFiles = () => {
    var debug, j, len1, recentChgd, recentFname, recentTime, res, usbDate, usbFilePath, usbFiles, usbLine;
    // console.log ".... checking for files to delete ...."
    usbFiles = exec(findUsb, {
      timeout: 300000
    }).toString().split('\n');
    for (j = 0, len1 = usbFiles.length; j < len1; j++) {
      usbLine = usbFiles[j];
      debug = false;
      // if usbLine.indexOf('horty') > -1
      //   console.log 'DEBUG:', usbLine
      //   debug = true
      usbDate = new Date(usbLine.slice(0, 10)).getTime();
      if (usbDate < usbAgeLimit) {
        usbFilePath = usbLine.slice(11);
        deleteCount++;
        console.log('removing old file:', usbFilePath);
        res = exec(`ssh ${usbHost} rm -rf ${escQuotesS("files/" + usbFilePath)}`, {
          timeout: 300000
        }).toString();
      }
    }
    recentChgd = false;
    for (recentFname in recent) {
      recentTime = recent[recentFname];
      if (!(recentTime < recentLimit)) {
        continue;
      }
      delete recent[recentFname];
      recentChgd = true;
    }
    if (recentChgd) {
      fs.writeFileSync('tv-recent.json', JSON.stringify(recent));
    }
    return process.nextTick(checkFiles);
  };

  //###########################################################
  // check each remote file, compute series and episode numbers
  usbFilePath = usbFiles = seriesName = season = fname = title = season = type = null;

  tvDbErrCount = 0;

  checkFiles = () => {
    usbFiles = exec(findUsb, {
      timeout: 300000
    }).toString().split('\n');
    if (filterRegex) {
      console.log(usbFiles);
    }
    return process.nextTick(checkFile);
  };

  checkFile = () => {
    var blkName, fext, guessItRes, parts, usbLine;
    tvDbErrCount = 0;
    if (usbLine = usbFiles.shift()) {
      chkCount++;
      usbFilePath = usbLine.slice(11);
      parts = usbFilePath.split('/');
      fname = parts[parts.length - 1];
      parts = fname.split('.');
      fext = parts[parts.length - 1];
      if (fext.length === 6 || (fext === 'nfo' || fext === 'idx' || fext === 'sub' || fext === 'txt' || fext === 'jpg' || fext === 'gif' || fext === 'jpeg' || fext === 'part')) {
        process.nextTick(checkFile);
        return;
      }
      if (recent[fname]) {
        recentCount++;
        // console.log '------', downloadCount,'/', chkCount, 'SKIPPING RECENT:', fname
        process.nextTick(checkFile);
        return;
      }
      for (blkName in blocked) {
        if (fname.indexOf(blkName) > -1) {
          recent[fname] = Date.now();
          fs.writeFileSync('tv-recent.json', JSON.stringify(recent));
          blockedCount++;
          console.log('------', downloadCount, '/', chkCount, 'SKIPPING BLOCKED:', fname);
          process.nextTick(checkFile);
          return;
        }
      }
      if (errors[fname]) {
        // console.log '------', downloadCount,'/', chkCount, 'SKIPPING *ERROR*:', fname
        process.nextTick(checkFile);
        return;
      }
      console.log('>>>>>>', downloadCount, '/', chkCount, errCount, fname);
      guessItRes = exec(`/usr/local/bin/guessit -js '${fname.replace(/'/g, '')}'`, {
        timeout: 300000
      }).toString();
      try {
        // console.log {guessItRes}
        ({title, season, type} = JSON.parse(guessItRes));
        if (!type === 'episode') {
          console.log('\nskipping non-episode:', fname);
          process.nextTick(badFile);
          return;
        }
        if (!Number.isInteger(season)) {
          console.log('\nno season integer for ' + fname + ', defaulting to season 1');
          season = 1;
        }
      } catch (error1) {
        console.error('\nerror parsing:' + fname);
        process.nextTick(badFile);
        return;
      }
      return process.nextTick(chkTvDB);
    } else {
      console.log('.... done ....');
      if ((deleteCount + existsCount + errCount + downloadCount + blockedCount) > 0) {
        console.log("***********************************************************");
      }
      if (recentCount > 0) {
        console.log('skipped recent:  ', recentCount);
      }
      if (blockedCount > 0) {
        console.log('blocked:         ', blockedCount);
      }
      if (deleteCount > 0) {
        console.log('deleted:         ', deleteCount);
      }
      if (existsCount > 0) {
        console.log('skipped existing:', existsCount);
      }
      if (errCount > 0) {
        console.log('errors:          ', errCount);
      }
      if (downloadCount > 0) {
        console.log('downloaded:      ', downloadCount);
      }
      console.log('elapsed(mins):   ', ((Date.now() - startTime) / (60 * 1000)).toFixed(1));
      if ((deleteCount + existsCount + errCount + downloadCount + blockedCount) > 0) {
        return console.log("***********************************************************");
      }
    }
  };

  tvdbCache = {};

  chkTvDB = () => {
    var tvdburl;
    if (tvdbCache[title]) {
      seriesName = tvdbCache[title];
      process.nextTick(checkFileExists);
      return;
    }
    tvdburl = 'https://api.thetvdb.com/search/series?name=' + encodeURIComponent(title);
    return request(tvdburl, {
      json: true,
      headers: {
        Authorization: 'Bearer ' + theTvDbToken
      }
    }, (error, response, body) => {
      // console.log 'thetvdb', {tvdburl, error, response, body}
      if (error || ((response != null ? response.statusCode : void 0) !== 200)) {
        console.error('no series name found in theTvDB:', fname);
        console.error('search error:', error);
        console.error('search statusCode:', response && response.statusCode);
        console.error('search body:', body);
        if (error) {
          if (++tvDbErrCount === 15) {
            console.error('giving up, downloaded:', downloadCount);
            return;
          }
          console.error("tvdb err retry, waiting one minute");
          return setTimeout(chkTvDB, 300000);
        } else {
          return process.nextTick(badFile);
        }
      } else {
        seriesName = body.data[0].seriesName;
        if (map[seriesName]) {
          console.log('+++ Mapping', seriesName, 'to', map[seriesName]);
          seriesName = map[seriesName];
        }
        tvdbCache[title] = seriesName;
        return process.nextTick(checkFileExists);
      }
    });
  };

  checkFileExists = () => {
    var tvFilePath, tvSeasonPath, usbLongPath, videoPath;
    tvSeasonPath = `${tvPath}${seriesName}/Season ${season}`;
    tvFilePath = `${tvSeasonPath}/${fname}`;
    videoPath = `files/${usbFilePath}`;
    usbLongPath = `${usbHost}:${videoPath}`;
    if (fs.existsSync(tvFilePath)) {
      existsCount++;
      console.log("... skipping existing file ...");
    } else {
      mkdirp.sync(tvSeasonPath);
      if (usbFilePath.indexOf('/') > -1) {
        console.log(`... downloading file (dir: ${usbFilePath}) ...`);
      } else {
        console.log("... downloading file ...");
      }
      // console.log escQuotes tvSeasonPath
      // console.log escQuotes tvFilePath
      // console.log escQuotes videoPath
      // console.log escQuotes usbLongPath
      // console.log "\nrsync -av #{escQuotesS usbLongPath} #{escQuotes tvFilePath}\n"
      console.log(exec(`rsync -av ${escQuotesS(usbLongPath)} ${escQuotes(tvFilePath)}`, fileTimeout).toString().replace('\n\n', '\n'), ((Date.now() - time) / 1000).toFixed(0) + ' secs');
      downloadCount++;
      time = Date.now();
    }
    recent[fname] = Date.now();
    fs.writeFileSync('tv-recent.json', JSON.stringify(recent));
    return process.nextTick(checkFile);
  };

  badFile = () => {
    errCount++;
    errors[fname] = true;
    fs.writeFileSync('tv-errors', JSON.stringify(errors));
    return process.nextTick(checkFile);
  };

}).call(this);
