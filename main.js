// Generated by CoffeeScript 2.4.1
(function() {
  //todo
  //  lazy-login to thetvdb
  //  add episode dupes to counter summary
  //  move episode dupes code to this file
  var badFile, checkFile, checkFileExists, checkFiles, chkCount, chkTvDB, delOldFiles, deleteCount, downloadCount, errCount, errors, escQuotes, escQuotesS, exec, existsCount, f, fileTimeout, filterRegex, filterRegexTxt, findUsb, fname, fs, getUsbFiles, i, len, line, map, mapLines, mapStr, mkdirp, recent, recentCount, recentLimit, request, rimraf, season, seriesName, startTime, t, theTvDbToken, time, title, tvDbErrCount, tvPath, tvdbCache, type, usbAgeLimit, usbFilePath, usbFiles, usbHost, util;

  usbHost = "xobtlu@lw987.usbx.me";

  usbAgeLimit = Date.now() - 8 * 7 * 24 * 60 * 60 * 1000; // 8 weeks ago

  recentLimit = Date.now() - 9 * 7 * 24 * 60 * 60 * 1000; // 9 weeks ago

  fileTimeout = {
    timeout: 2 * 60 * 60 * 1000 // 2 hours
  };

  fs = require('fs-plus');

  util = require('util');

  exec = require('child_process').execSync;

  mkdirp = require('mkdirp');

  request = require('request');

  rimraf = require('rimraf');

  filterRegex = null;

  filterRegexTxt = '';

  if (process.argv.length === 3) {
    filterRegex = process.argv[2];
    filterRegexTxt = 'filter:' + filterRegex;
  }

  console.log(`.... starting tv.coffee v3 ${filterRegexTxt} ....`);

  startTime = time = Date.now();

  deleteCount = chkCount = recentCount = existsCount = errCount = downloadCount = 0;

  findUsb = `ssh ${usbHost} find files -type f -printf '%CY-%Cm-%Cd-%P\\\\\\n' | grep -v .r[0-9][0-9]$ | grep -v .rar$`;

  if (filterRegex) {
    findUsb += " | grep " + filterRegex;
  }

  //##########
  // constants
  map = {};

  mapStr = fs.readFileSync('tv-map', 'utf8');

  mapLines = mapStr.split('\n');

  for (i = 0, len = mapLines.length; i < len; i++) {
    line = mapLines[i];
    [f, t] = line.split(',');
    if (line.length) {
      map[f.trim()] = t.trim();
    }
  }

  recent = JSON.parse(fs.readFileSync('tv-recent.json', 'utf8'));

  errors = JSON.parse(fs.readFileSync('tv-errors', 'utf8'));

  tvPath = '/mnt/media/tv/';

  escQuotesS = function(str) {
    return '"' + str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/'/g, "\\'").replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\s/g, '\\ ') + '"';
  };

  escQuotes = function(str) {
    return '"' + str.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
  };

  // '"' + str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/'/g, "\\'") + '"'

  //###############
  // async routines
  getUsbFiles = delOldFiles = checkFiles = checkFile = badFile = checkFileExists = checkFile = chkTvDB = null;

  //######################################
  // get theTvDb api token
  theTvDbToken = null;

  request.post('https://api.thetvdb.com/login', {
    json: true,
    body: {
      apikey: "2C92771D87CA8718"
    }
  }, (error, response, body) => {
    if (error || response.statusCode !== 200) {
      console.error('theTvDb login error:', error);
      console.error('theTvDb statusCode:', response && response.statusCode);
      return process.exit();
    } else {
      theTvDbToken = body.token;
      return process.nextTick(delOldFiles);
    }
  });

  //#####################################################
  // delete old files in usb/files
  delOldFiles = () => {
    var j, len1, recentChgd, recentFname, recentTime, res, usbDate, usbFilePath, usbFiles, usbLine;
    // console.log ".... checking for files to delete ...."
    usbFiles = exec(findUsb, {
      timeout: 300000
    }).toString().split('\n');
    for (j = 0, len1 = usbFiles.length; j < len1; j++) {
      usbLine = usbFiles[j];
      usbDate = new Date(usbLine.slice(0, 10)).getTime();
      if (usbDate < usbAgeLimit) {
        usbFilePath = usbLine.slice(11);
        deleteCount++;
        console.log('removing old file:', usbFilePath);
        res = exec(`ssh ${usbHost} rm -rf ${escQuotesS("files/" + usbFilePath)}`, {
          timeout: 300000
        }).toString();
      }
    }
    recentChgd = false;
    for (recentFname in recent) {
      recentTime = recent[recentFname];
      if (!(recentTime < recentLimit)) {
        continue;
      }
      delete recent[recentFname];
      recentChgd = true;
    }
    if (recentChgd) {
      fs.writeFileSync('tv-recent.json', JSON.stringify(recent));
    }
    return process.nextTick(checkFiles);
  };

  //###########################################################
  // check each remote file, compute series and episode numbers
  usbFilePath = usbFiles = seriesName = season = fname = title = season = type = null;

  tvDbErrCount = 0;

  checkFiles = () => {
    usbFiles = exec(findUsb, {
      timeout: 300000
    }).toString().split('\n');
    if (filterRegex) {
      console.log(usbFiles);
    }
    return process.nextTick(checkFile);
  };

  checkFile = () => {
    var fext, guessItRes, parts, usbLine;
    tvDbErrCount = 0;
    if (usbLine = usbFiles.shift()) {
      chkCount++;
      usbFilePath = usbLine.slice(11);
      parts = usbFilePath.split('/');
      fname = parts[parts.length - 1];
      parts = fname.split('.');
      fext = parts[parts.length - 1];
      if (fext.length === 6 || (fext === 'nfo' || fext === 'idx' || fext === 'sub' || fext === 'txt' || fext === 'jpg' || fext === 'gif' || fext === 'jpeg' || fext === 'part')) {
        process.nextTick(checkFile);
        return;
      }
      if (recent[fname]) {
        recentCount++;
        // console.log '------', downloadCount,'/', chkCount, 'SKIPPING RECENT:', fname
        process.nextTick(checkFile);
        return;
      }
      if (errors[fname]) {
        // console.log '------', downloadCount,'/', chkCount, 'SKIPPING *ERROR*:', fname
        process.nextTick(checkFile);
        return;
      }
      console.log('>>>>>>', downloadCount, '/', chkCount, errCount, fname);
      guessItRes = exec(`/usr/local/bin/guessit -js '${fname.replace(/'/g, '')}'`, {
        timeout: 300000
      }).toString();
      try {
        // console.log {guessItRes}
        ({title, season, type} = JSON.parse(guessItRes));
        if (!type === 'episode') {
          console.log('\nskipping non-episode:', fname);
          process.nextTick(badFile);
          return;
        }
        if (!Number.isInteger(season)) {
          console.log('\nno season integer for ' + fname);
          process.nextTick(badFile);
          return;
        }
      } catch (error1) {
        console.error('\nerror parsing:' + fname);
        process.nextTick(badFile);
        return;
      }
      return process.nextTick(chkTvDB);
    } else {
      console.log('.... done ....');
      if (recentCount > 0) {
        console.log('skipped recent:  ', recentCount);
      }
      if (deleteCount > 0) {
        console.log('deleted:         ', deleteCount);
      }
      if (existsCount > 0) {
        console.log('skipped existing:', existsCount);
      }
      if (errCount > 0) {
        console.log('errors:          ', errCount);
      }
      if (downloadCount > 0) {
        console.log('downloaded:      ', downloadCount);
      }
      console.log('elapsed(mins):   ', ((Date.now() - startTime) / (60 * 1000)).toFixed(1));
      if (deleteCount + existsCount + errCount + downloadCount > 0) {
        return console.log("***********************************************************");
      }
    }
  };

  tvdbCache = {};

  chkTvDB = () => {
    if (tvdbCache[title]) {
      seriesName = tvdbCache[title];
      process.nextTick(checkFileExists);
      return;
    }
    return request('https://api.thetvdb.com/search/series?name=' + encodeURIComponent(title), {
      json: true,
      headers: {
        Authorization: 'Bearer ' + theTvDbToken
      }
    }, (error, response, body) => {
      // console.log 'thetvdb', {error, response, body}
      if (error || ((response != null ? response.statusCode : void 0) !== 200)) {
        console.error('no series name found in theTvDB:', fname);
        console.error('search error:', error);
        console.error('search statusCode:', response && response.statusCode);
        console.error('search body:', body);
        if (error) {
          if (++tvDbErrCount === 15) {
            console.error('giving up, downloaded:', downloadCount);
            return;
          }
          console.error("tvdb err retry, waiting one minute");
          return setTimeout(chkTvDB, 300000);
        } else {
          return process.nextTick(badFile);
        }
      } else {
        seriesName = body.data[0].seriesName;
        if (map[seriesName]) {
          console.log('+++ Mapping', seriesName, 'to', map[seriesName]);
          seriesName = map[seriesName];
        }
        tvdbCache[title] = seriesName;
        return process.nextTick(checkFileExists);
      }
    });
  };

  checkFileExists = () => {
    var tvFilePath, tvSeasonPath, usbLongPath, videoPath;
    tvSeasonPath = `${tvPath}${seriesName}/Season ${season}`;
    tvFilePath = `${tvSeasonPath}/${fname}`;
    videoPath = `files/${usbFilePath}`;
    usbLongPath = `${usbHost}:${videoPath}`;
    if (fs.existsSync(tvFilePath)) {
      existsCount++;
      console.log("... skipping existing file ...");
    } else {
      mkdirp.sync(tvSeasonPath);
      if (usbFilePath.indexOf('/') > -1) {
        console.log(`... downloading file (dir: ${usbFilePath}) ...`);
      } else {
        console.log("... downloading file ...");
      }
      // console.log escQuotes tvSeasonPath
      // console.log escQuotes tvFilePath
      // console.log escQuotes videoPath
      // console.log escQuotes usbLongPath
      // console.log "\nrsync -av #{escQuotesS usbLongPath} #{escQuotes tvFilePath}\n"
      console.log(exec(`rsync -av ${escQuotesS(usbLongPath)} ${escQuotes(tvFilePath)}`, fileTimeout).toString().replace('\n\n', '\n'), ((Date.now() - time) / 1000).toFixed(0) + ' secs');
      downloadCount++;
      time = Date.now();
    }
    recent[fname] = Date.now();
    fs.writeFileSync('tv-recent.json', JSON.stringify(recent));
    return process.nextTick(checkFile);
  };

  badFile = () => {
    errCount++;
    errors[fname] = true;
    fs.writeFileSync('tv-errors', JSON.stringify(errors));
    return process.nextTick(checkFile);
  };

}).call(this);
